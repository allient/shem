use anyhow::Result;
use shem_core::{
    Table, View, MaterializedView, Function, Procedure,
    Type, Domain, Sequence, Extension, Trigger, Policy, Server,
    SqlGenerator, CheckOption, TypeKind, TriggerEvent, TriggerTiming,
    ParameterMode
};

/// PostgreSQL SQL generator
#[derive(Debug, Clone)]
pub struct PostgresSqlGenerator;

impl SqlGenerator for PostgresSqlGenerator {
    fn generate_create_table(&self, table: &Table) -> Result<String> {
        let mut sql = format!("CREATE TABLE {} (", table.name);
        let mut columns = Vec::new();

        // Add columns
        for column in &table.columns {
            let mut col_def = format!("{} {}", column.name, column.type_name);
            if !column.nullable {
                col_def.push_str(" NOT NULL");
            }
            if let Some(default) = &column.default {
                col_def.push_str(&format!(" DEFAULT {}", default));
            }
            if let Some(identity) = &column.identity {
                col_def.push_str(if identity.always { " GENERATED ALWAYS AS IDENTITY" } else { " GENERATED BY DEFAULT AS IDENTITY" });
            }
            if let Some(generated) = &column.generated {
                col_def.push_str(&format!(" GENERATED ALWAYS AS ({}) STORED", generated.expression));
            }
            columns.push(col_def);
        }

        // Add constraints
        for constraint in &table.constraints {
            columns.push(constraint.definition.clone());
        }

        sql.push_str(&columns.join(",\n    "));
        sql.push_str("\n);");

        Ok(sql)
    }

    fn generate_alter_table(&self, old: &Table, new: &Table) -> Result<(Vec<String>, Vec<String>)> {
        let mut up_statements = Vec::new();
        let mut down_statements = Vec::new();

        // Handle column changes
        for new_col in &new.columns {
            if !old.columns.iter().any(|c| c.name == new_col.name) {
                // New column
                let mut col_def = format!("ALTER TABLE {} ADD COLUMN {} {}", 
                    new.name, new_col.name, new_col.type_name);
                if !new_col.nullable {
                    col_def.push_str(" NOT NULL");
                }
                if let Some(default) = &new_col.default {
                    col_def.push_str(&format!(" DEFAULT {}", default));
                }
                up_statements.push(col_def);
                down_statements.push(format!("ALTER TABLE {} DROP COLUMN {}", 
                    old.name, new_col.name));
            }
        }

        // Handle constraint changes
        for new_constraint in &new.constraints {
            if !old.constraints.iter().any(|c| c.name == new_constraint.name) {
                up_statements.push(format!("ALTER TABLE {} ADD CONSTRAINT {} {}", 
                    new.name, new_constraint.name, new_constraint.definition));
                down_statements.push(format!("ALTER TABLE {} DROP CONSTRAINT {}", 
                    old.name, new_constraint.name));
            }
        }

        Ok((up_statements, down_statements))
    }

    fn generate_drop_table(&self, table: &Table) -> Result<String> {
        Ok(format!("DROP TABLE IF EXISTS {} CASCADE;", table.name))
    }

    fn create_view(&self, view: &View) -> Result<String> {
        let mut sql = format!("CREATE VIEW {} AS {}", view.name, view.definition);
        match view.check_option {
            CheckOption::None => {},
            CheckOption::Local => sql.push_str(" WITH LOCAL CHECK OPTION"),
            CheckOption::Cascaded => sql.push_str(" WITH CASCADED CHECK OPTION"),
        }
        sql.push(';');
        Ok(sql)
    }

    fn create_materialized_view(&self, view: &MaterializedView) -> Result<String> {
        Ok(format!(
            "CREATE MATERIALIZED VIEW {} AS {}\nWITH DATA;",
            view.name, view.definition
        ))
    }

    fn create_function(&self, function: &Function) -> Result<String> {
        let params = function
            .parameters
            .iter()
            .map(|p| format!("{} {} {:?}", p.name, p.type_name, p.mode))
            .collect::<Vec<_>>()
            .join(", ");

        let returns = format!("RETURNS {}", function.returns.type_name);
        let language = function.language.to_lowercase();
        let body = function.definition.trim();
        let schema = function.schema.as_deref().unwrap_or("public");

        Ok(format!(
            "CREATE OR REPLACE FUNCTION {}.{}({}) {} LANGUAGE {} AS $function$ {} $function$",
            schema, function.name, params, returns, language, body
        ))
    }

    fn create_procedure(&self, procedure: &Procedure) -> Result<String> {
        let params = procedure
            .parameters
            .iter()
            .map(|p| format!("{} {} {:?}", p.name, p.type_name, p.mode))
            .collect::<Vec<_>>()
            .join(", ");

        let language = procedure.language.to_lowercase();
        let body = procedure.definition.trim();
        let schema = procedure.schema.as_deref().unwrap_or("public");

        Ok(format!(
            "CREATE OR REPLACE PROCEDURE {}.{}({}) LANGUAGE {} AS $procedure$ {} $procedure$",
            schema, procedure.name, params, language, body
        ))
    }

    fn generate_create_type(&self, type_def: &Type) -> Result<String> {
        match type_def.kind {
            TypeKind::Enum => {
                // TODO: Implement enum type creation
                unimplemented!()
            },
            TypeKind::Domain => {
                // TODO: Implement domain type creation
                unimplemented!()
            },
            TypeKind::Composite => {
                // TODO: Implement composite type creation
                unimplemented!()
            },
            TypeKind::Range => {
                // TODO: Implement range type creation
                unimplemented!()
            },
            TypeKind::Base => {
                // Base types are built-in
                Ok(String::new())
            },
        }
    }

    fn create_enum(&self, enum_type: &Type) -> Result<String> {
        // TODO: Implement enum type creation
        unimplemented!()
    }

    fn alter_enum(&self, old: &Type, new: &Type) -> Result<(Vec<String>, Vec<String>)> {
        // TODO: Implement enum type alteration
        unimplemented!()
    }

    fn create_domain(&self, domain: &Domain) -> Result<String> {
        let mut sql = format!(
            "CREATE DOMAIN {} AS {}",
            domain.name, domain.base_type
        );
        if !domain.constraints.is_empty() {
            sql.push_str(&format!(
                " CHECK ({})",
                domain.constraints.join(" AND ")
            ));
        }
        sql.push(';');
        Ok(sql)
    }

    fn create_sequence(&self, seq: &Sequence) -> Result<String> {
        let mut sql = format!(
            "CREATE SEQUENCE {} START {} INCREMENT {}",
            seq.name, seq.start, seq.increment
        );
        if let Some(min) = seq.min_value {
            sql.push_str(&format!(" MINVALUE {}", min));
        }
        if let Some(max) = seq.max_value {
            sql.push_str(&format!(" MAXVALUE {}", max));
        }
        sql.push_str(&format!(" CACHE {}", seq.cache));
        if seq.cycle {
            sql.push_str(" CYCLE");
        }
        sql.push(';');
        Ok(sql)
    }

    fn alter_sequence(&self, old: &Sequence, new: &Sequence) -> Result<(Vec<String>, Vec<String>)> {
        let mut up_statements = Vec::new();
        let mut down_statements = Vec::new();

        // Handle start value changes
        if old.start != new.start {
            up_statements.push(format!(
                "ALTER SEQUENCE {} RESTART WITH {};",
                new.name, new.start
            ));
            down_statements.push(format!(
                "ALTER SEQUENCE {} RESTART WITH {};",
                old.name, old.start
            ));
        }

        // Handle increment changes
        if old.increment != new.increment {
            up_statements.push(format!(
                "ALTER SEQUENCE {} INCREMENT BY {};",
                new.name, new.increment
            ));
            down_statements.push(format!(
                "ALTER SEQUENCE {} INCREMENT BY {};",
                old.name, old.increment
            ));
        }

        // Handle min value changes
        if old.min_value != new.min_value {
            let up_min = match new.min_value {
                Some(min) => format!("SET MINVALUE {}", min),
                None => "NO MINVALUE".to_string(),
            };
            let down_min = match old.min_value {
                Some(min) => format!("SET MINVALUE {}", min),
                None => "NO MINVALUE".to_string(),
            };
            up_statements.push(format!("ALTER SEQUENCE {} {};", new.name, up_min));
            down_statements.push(format!("ALTER SEQUENCE {} {};", old.name, down_min));
        }

        // Handle max value changes
        if old.max_value != new.max_value {
            let up_max = match new.max_value {
                Some(max) => format!("SET MAXVALUE {}", max),
                None => "NO MAXVALUE".to_string(),
            };
            let down_max = match old.max_value {
                Some(max) => format!("SET MAXVALUE {}", max),
                None => "NO MAXVALUE".to_string(),
            };
            up_statements.push(format!("ALTER SEQUENCE {} {};", new.name, up_max));
            down_statements.push(format!("ALTER SEQUENCE {} {};", old.name, down_max));
        }

        // Handle cache changes
        if old.cache != new.cache {
            up_statements.push(format!(
                "ALTER SEQUENCE {} CACHE {};",
                new.name, new.cache
            ));
            down_statements.push(format!(
                "ALTER SEQUENCE {} CACHE {};",
                old.name, old.cache
            ));
        }

        // Handle cycle changes
        if old.cycle != new.cycle {
            let cycle_str = if new.cycle { "CYCLE" } else { "NO CYCLE" };
            let old_cycle_str = if old.cycle { "CYCLE" } else { "NO CYCLE" };
            up_statements.push(format!("ALTER SEQUENCE {} {};", new.name, cycle_str));
            down_statements.push(format!("ALTER SEQUENCE {} {};", old.name, old_cycle_str));
        }

        Ok((up_statements, down_statements))
    }

    fn create_extension(&self, ext: &Extension) -> Result<String> {
        Ok(format!(
            "CREATE EXTENSION IF NOT EXISTS {} VERSION '{}';",
            ext.name, ext.version
        ))
    }

    fn create_trigger(&self, trigger: &Trigger) -> Result<String> {
        let events: Vec<&str> = trigger.events.iter().map(|e| match e {
            TriggerEvent::Insert => "INSERT",
            TriggerEvent::Update => "UPDATE",
            TriggerEvent::Delete => "DELETE",
            TriggerEvent::Truncate => "TRUNCATE",
        }).collect();

        let timing = match trigger.timing {
            TriggerTiming::Before => "BEFORE",
            TriggerTiming::After => "AFTER",
            TriggerTiming::InsteadOf => "INSTEAD OF",
        };

        let events_str = events.join(" OR ");
        let function = &trigger.function; // Function is already in the format 'schema.function'

        let args = if !trigger.arguments.is_empty() {
            format!("({})", trigger.arguments.join(", "))
        } else {
            String::new()
        };

        Ok(format!(
            "CREATE TRIGGER {} {} {} ON {} FOR EACH ROW EXECUTE FUNCTION {}{}",
            trigger.name, timing, events_str, trigger.table, function, args
        ))
    }

    fn create_policy(&self, policy: &Policy) -> Result<String> {
        let mut sql = format!(
            "CREATE POLICY {} ON {} AS {}",
            policy.name,
            policy.table,
            if policy.permissive { "PERMISSIVE" } else { "RESTRICTIVE" }
        );

        if !policy.roles.is_empty() {
            sql.push_str(&format!(
                " FOR {}",
                policy.roles.join(", ")
            ));
        }

        if let Some(using) = &policy.using {
            sql.push_str(&format!(" USING ({})", using));
        }

        if let Some(check) = &policy.check {
            sql.push_str(&format!(" WITH CHECK ({})", check));
        }

        sql.push(';');
        Ok(sql)
    }

    fn create_server(&self, server: &Server) -> Result<String> {
        let options = server.options.iter()
            .map(|(k, v)| format!("{} '{}'", k, v))
            .collect::<Vec<_>>()
            .join(", ");

        Ok(format!(
            "CREATE SERVER {} FOREIGN DATA WRAPPER {} OPTIONS ({});",
            server.name,
            server.foreign_data_wrapper,
            options
        ))
    }
} 